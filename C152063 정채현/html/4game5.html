<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>동물 게임</title>
    <link rel="stylesheet" href="../css/style.css">
</head>
<body>
    <div id="wrap" class="stage5wrap">
        <header>
            <h1>들키지 않게 이동하자!</h1>
        </header>
        <div id="container">
            <div id="content">

              <div id="game-area" class="bgg5">
                <div class="obstacle ob1 animal"></div>
                <div class="obstacle ob2 animal"></div>
                <div class="obstacle ob3 animal"></div>
                <div class="obstacle ob4 animal"></div>
                <div class="watch watch1"></div>
                <div class="watch watch2"></div>
                <div class="player"></div>
                <div class="hearts">
                  <img src="../img/heart.png" class="heart">
                  <img src="../img/heart.png" class="heart">
                  <img src="../img/heart.png" class="heart">
                </div>
              </div>


              <div class="modal">
                <div class="modal-content">
                  <h2>게임 오버</h2>
                  <p>어떻게 할까?</p>
                  <div class="button-row">
                    <button class="restartBtn">다시 하기
                      <span class="tooltip-text">▶ 맨 처음으로</span>
                    </button>
                    <button class="homeBtn">잠시 쉬기
                      <span class="tooltip-text">▶ 홈으로</span>
                    </button>
                  </div>
                </div>
              </div>

            </div>
        </div>
    </div>

<script>
// 모달 
const gameOverModal = document.querySelector('.modal');
const restartBtn = document.querySelector('.restartBtn');
const homeBtn = document.querySelector('.homeBtn');

//홈으로
homeBtn.addEventListener('click', () => {
  window.location.href = '2home.html';
});

// 플레이어와 감시 빛
const player = document.querySelector('.player');
const watch1 = document.querySelector('.watch1');
const watch2 = document.querySelector('.watch2');
const obstacles = document.querySelectorAll('.obstacle');

// 플레이어 위치 좌표 (초기값)
let playerX = 30;
let playerY = 500;

// 감시 빛 좌우 이동을 위한 변수
let watchX1 = 250;
let watchX2 = 340;
let watchSpeed1 = 1.5;
let watchSpeed2 = 2.5;
let direction = -1;
const watchPath = [
  { to: 0, dir: -1 },
  { to: 500, dir: 1 }
];
let currentPathIndex1 = 0;
let currentPathIndex2 = 1;



// 이동 속도 (한 번 누를 때 움직이는 픽셀 수)
const playerSpeed = 3;

// 키 입력 상태 저장 객체
const keys = {};

// 키가 눌렸을 때 true로 저장
window.addEventListener('keydown', e => {
  keys[e.key.toLowerCase()] = true;
});

// 키를 뗐을 때 false로 저장
window.addEventListener('keyup', e => {
  keys[e.key.toLowerCase()] = false;
});



// 플레이어 위치 업데이트
function updatePlayer() {
  // 왼쪽 화살표 키가 눌렸을 때
  if (keys['arrowleft']) playerX -= playerSpeed;

  // 오른쪽 화살표 키가 눌렸을 때
  if (keys['arrowright']) playerX += playerSpeed;

  // 화면 경계 안으로 제한
  if (playerX < 0) playerX = 0;
  if (playerX > 750) playerX = 750; // (800px - 플레이어 width 50px)

  // 실제 HTML 요소에 위치 반영
  player.style.left = playerX + 'px';
}

//감시영역 이동
function updateWatch1() {
  const target = watchPath[currentPathIndex1];
  watchX1 += watchSpeed1 * target.dir;

  if ((target.dir === -1 && watchX1 <= target.to) || (target.dir === 1 && watchX1 >= target.to)) {
    currentPathIndex1 = (currentPathIndex1 + 1) % watchPath.length;
    watchSpeed1 = (target.to === 0 && watchPath[currentPathIndex1].dir === 1) ? 3.0 : 2.0;
  }
  watch1.style.left = watchX1 + 'px';
}

function updateWatch2() {
  const target = watchPath[currentPathIndex2];
  watchX2 += watchSpeed2 * target.dir;

  if ((target.dir === -1 && watchX2 <= target.to) || (target.dir === 1 && watchX2 >= target.to)) {
    currentPathIndex2 = (currentPathIndex2 + 1) % watchPath.length;
    watchSpeed2 = (target.to === 0 && watchPath[currentPathIndex2].dir === 1) ? 3.0 : 2.0;
  }
  watch2.style.left = watchX2 + 'px';
}

function isPlayerBehindObstacle() {
  const playerRect = player.getBoundingClientRect();

  for (let ob of obstacles) {
    const obRect = ob.getBoundingClientRect();

    // 플레이어가 기둥과 겹치는지 확인
    const isOverlapping = !(
      playerRect.right < obRect.left ||
      playerRect.left > obRect.right ||
      playerRect.bottom < obRect.top ||
      playerRect.top > obRect.bottom
    );

    if (isOverlapping) {
      return true; // 플레이어가 기둥 뒤에 있다는 뜻
    }
  }
  return false;
}




// 게임 시작
let isGameOver = false;
let isGameClear = false;


function gameLoop() {
  if (!isGameOver && !isGameClear) {
    updatePlayer();
    updateWatch1();
    updateWatch2();

    if (
      (isColliding(player, watch1) && !isPlayerBehindObstacle()) ||
      (isColliding(player, watch2) && !isPlayerBehindObstacle())
    ) {
      isGameOver = true;
      loseHeart();
    }

    if (playerX >= 750) {
      sessionStorage.setItem('stage5Cleared', 'true');
      window.location.href = "5clear5.html";
      isGameClear = true;
      return;
    }
  }
  requestAnimationFrame(gameLoop);
}

// ========== 하트
// 전역에서 접근 가능하게 이동
function updateHeartsUI() {
  const hearts = parseInt(sessionStorage.getItem('hearts') || '3', 10);
  const heartEls = document.querySelectorAll('.heart');

  heartEls.forEach((el, index) => {
    el.style.opacity = index < hearts ? '1' : '0.3';
  });
}

// 충돌 발생 시 호출
function onPlayerCaught() {
  loseHeart();
  showGameOver();
}

function loseHeart() {
  let hearts = parseInt(sessionStorage.getItem('hearts') || '3', 10);

  hearts -= 1;
  sessionStorage.setItem('hearts', hearts.toString());
  updateHeartsUI();

  if (hearts > 0) {
    // 하트가 남아있으면 모달 띄우기
    showGameOver();
  } else {
    // 하트 0이면 바로 배드 엔딩으로
    window.location.href = '6badEnding.html';
  }
}


//초기화
document.addEventListener('DOMContentLoaded', () => {
  let hearts = sessionStorage.getItem('hearts');
  if (hearts === null) {
    hearts = '3';
    sessionStorage.setItem('hearts', hearts);
  }
  updateHeartsUI();

  gameLoop();
});




// ========== 게임오버 처리
function showGameOver() {
  gameOverModal.classList.add('active');
}

// 리플레이 버튼 클릭 시
restartBtn.addEventListener('click', () => {
  gameOverModal.classList.remove('active');
  resetGame();
});

function isColliding(el1, el2) {
  const rect1 = el1.getBoundingClientRect();
  const rect2 = el2.getBoundingClientRect();

  return !(
    rect1.right < rect2.left ||
    rect1.left > rect2.right ||
    rect1.bottom < rect2.top ||
    rect1.top > rect2.bottom
  );
}


function resetGame() {
  playerX = 30;
  playerY = 500;
  player.style.left = playerX + 'px';

  watchX1 = 250;
  watchX2 = 340;
  watchSpeed1 = 1.5;
  watchSpeed2 = 2.5;
  currentPathIndex1 = 0;
  currentPathIndex2 = 1;

  watch1.style.left = watchX1 + 'px';
  watch2.style.left = watchX2 + 'px';

  for (let key in keys) {
    keys[key] = false;
  }

  isGameOver = false;
}


</script>

</body>
</html>